---
title: 'Database Primer in R'
author: "Brandon Farr"
date: 2021-12-23
output:
    github_document: default
---

```{r setup, include = FALSE}
library(DBI)
library(RSQLite)
library(tidyverse)

knitr::opts_chunk$set(
    # connection = "sampledb", # automatically uses this connection in sql chunks 
    comment = "#>", 
    collapse = TRUE, 
    message = FALSE,
    fig.width = 8,
    fig.asp = ((1 + sqrt(5)) / 2) - 1, # the golden ratio - technically, the b proportion of a+b when a is 1
    out.width = "70%",
    fig.align = "center"
)
```

## Ensure Database Integrity: Primary Key and Foreign Keys

Create a database with two tables: `parent` and `child`. Create a relationship
between the two tables using `PRIMARY KEY` and `FOREIGN KEY` to:

- ensure all entries in `child` relate to an **existing** record in `parent`
- ensure that when an entry in `parent` is deleted, all related records in
  `child` are deleted
  
The database schema we use is shown below.

```{sql eval = FALSE}

-- parent table
CREATE TABLE IF NOT EXISTS parent
(
    uid INTEGER PRIMARY KEY,
    parent_name TEXT NOT NULL
);

-- child table
CREATE TABLE IF NOT EXISTS child
(
    parent_uid INTEGER NOT NULL,
    child_name TEXT NOT NULL,
    FOREIGN KEY(parent_uid)
        REFERENCES parent(uid)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

```

Take note of: `PRIMARY KEY`, `FOREIGN KEY`, `REFERENCES` and
`ON DELETE CASCADE`.

This chunk references `DROP_PARENTCHILDDB_SCHEMA.SQL` as input to clear the
schema for new use in this script.

```{bash drop_schema, echo = TRUE}
sqlite3 PARENTCHILDDB < DROP_PARENTCHILDDB_SCHEMA.SQL
```


This chunk references `CREATE_PARENTCHILDDB_SCHEMA.SQL` as input to create
all of the schema objects for `PARENTCHILDDB`.

```{bash create_schema, echo = TRUE}
sqlite3 PARENTCHILDDB < CREATE_PARENTCHILDDB_SCHEMA.SQL
```

First, setup the connection object in R, so that you can interact with
the database.

```{r}

base_dir <- here::here()
db_file <- fs::path(base_dir, "PARENTCHILDDB")

if(dbCanConnect(RSQLite::SQLite(), db_file)) {
    parentchilddb <- dbConnect(RSQLite::SQLite(), db_file)
}

```

The next chunk - which is an `r` chunk - uses the `RSQLite` function
`dbListTables` to verify that the tables have been created.

```{r list_tables}
dbListTables(parentchilddb)

dbListFields(parentchilddb, "parent")

dbListFields(parentchilddb, "child")

```

Now, write some data into the `parent` table.

```{r}

parent_tbl <- tibble(
    uid = 1:2,
    parent_name = c("Adam", "Jacob")
)

dbAppendTable(parentchilddb, "parent", parent_tbl)

```

As a brief aside, let's define a function via our friend
[H. David Shea](https://github.com/hdshea/) that makes querying database
tables much easier in R. The main benefit is that the result is in a
`tibble`.

```{r}

db_select_data <- function(con, select_statement ) {
    res <- dbSendQuery(con, select_statement)
    rval <- tibble::tibble(dbFetch(res)) %>%
        mutate(across(contains("_date"), as.Date, origin = "1970-01-01"))
    dbClearResult(res)
    rm(res)
    rval
}

```

Now, use `db_select_data` to look at what is in the `parent` table.

```{r}

db_select_data(parentchilddb, "SELECT * FROM parent;")

```

Let's add a record in `child` that does not violate the FOREIGN KEY constraint.

```{r}

good_child_tbl <- tibble(
    parent_uid = 1,
    child_name = "Abel"
)

dbAppendTable(parentchilddb, "child", good_child_tbl)

db_select_data(parentchilddb, "SELECT * FROM child;")

```

As it currently stands is the database going to enforce integrity? Try
inserting a child with a `parent_uid` that is not in `parent`.

```{r}

bad_child_tbl <- tibble(
    parent_uid = 3,
    child_name = "Solomon"
)

dbAppendTable(parentchilddb, "child", bad_child_tbl)

db_select_data(parentchilddb, "SELECT * FROM child;")

```

### Enforce integrity with `PRAGMA foreign_keys = ON;`

Looks like the record was added, against our expectations. What happened?
Well, looks like `sqlite3` doesn't automatically enforce `FOREIGN KEY`
integrity unless during the connection session, you set a `PRAGMA`. So,
let's drop the current connection and set up a new one.

```{r}

# disconnect from current session
dbDisconnect(parentchilddb)

# reconnect and immediately make a PRAGMA call
if(dbCanConnect(RSQLite::SQLite(), db_file)) {
    parentchilddb <- dbConnect(RSQLite::SQLite(), db_file)
    
    # ensure foreign keys are enforced
    rs <- dbSendStatement(parentchilddb, "PRAGMA foreign_keys = ON;")
    dbHasCompleted(rs)
    dbClearResult(rs)
}

```

Now, try to insert a problematic record.

```{r}

another_bad_child_tbl <- tibble(
    parent_uid = 4,
    child_name = "Samuel"
)

safe_dbAppendTable <- safely(dbAppendTable)

safe_dbAppendTable(parentchilddb, "child", another_bad_child_tbl)

db_select_data(parentchilddb, "SELECT * FROM child;")

```

That's more like it. Let's reset the database and test what happens
when parents are deleted.

```{bash}

sqlite3 PARENTCHILDDB < DROP_PARENTCHILDDB_SCHEMA.SQL
sqlite3 PARENTCHILDDB < CREATE_PARENTCHILDDB_SCHEMA.SQL

```

```{r}
# add parents back into `parent` table
safe_dbAppendTable(parentchilddb, "parent", parent_tbl)

fill_children_tbl <- tibble(
    parent_uid = c(1, 1, rep(2, 13)),
    child_name = c(
        "Cain", "Abel",
        "Reuben", "Simeon", "Levi", "Judah",
        "Dan", "Naphtali", "Gad", "Asher",
        "Issachar", "Zebulun", "Dinah", "Joseph",
        "Benjamin"
    )
)

safe_dbAppendTable(parentchilddb, "child", fill_children_tbl)

db_select_data(parentchilddb, "SELECT * FROM child;")

```


### Cascading DELETEs

A key scenario to test when determining database integrity is
the deletion of children records related to a deleted parent. Does
`sqlite3` accomplish this? Let's try removing `Jacob` and see what
happens.

```{r}

safe_dbSendStatement <- safely(dbSendStatement)

safe_dbSendStatement(
    parentchilddb,
    "DELETE FROM parent WHERE parent_name = 'Jacob'"
)

db_select_data(parentchilddb, "SELECT * from parent;")

db_select_data(parentchilddb, "SELECT * from child;")

```

It looks like cascading deletes were enforced.

## Summary

What did we learn in this exercise?

> Creating and maintaining database integrity is a two-step
  process in sqlite3.
  
1. Proper schema setup using `FOREIGN KEY`, `REFERENCE` and
   `ON UPDATE`
   
```{sql eval = FALSE}

CREATE TABLE IF NOT EXISTS child
(
    parent_uid INTEGER NOT NULL,
    child_name TEXT NOT NULL,
    FOREIGN KEY(parent_uid)
        REFERENCES parent(uid)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

```

2. When connecting to the database use `PRAGMA foreign_keys = ON;`

```{r eval = FALSE}


if(dbCanConnect(RSQLite::SQLite(), db_file)) {
    parentchilddb <- dbConnect(RSQLite::SQLite(), db_file)
    
    # ensure foreign keys are enforced
    rs <- dbSendStatement(parentchilddb, "PRAGMA foreign_keys = ON;")
    dbHasCompleted(rs)
    dbClearResult(rs)
}

```